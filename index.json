[{"content":" View it on GitHub Linewriter Linewriter is a simple SOP that adds some functionality around the built-in Font SOP. It is most useful for creating text labels in the viewport for recording parameter values when flipbooking wedges etc.\nThis node was built in Houdini 19.0.455. While there is a version for Houdini 18.5, it will look and perform best in Houdini 19+\nOn macOS with UI scaling on, some parameters may not line up in a pretty way in Houdini 19.0. This has been reported to SideFX.\nProblems with built-in Font SOP There are a few slightly annoying gotchas when making HUDs/Overlays out of the Font SOP for recoding parameter values etc.\n1. Font SOP doesn\u0026rsquo;t play well with channel references When you\u0026rsquo;re building a HUD/Overlay with the default Font SOP, it can be tedious adding channel references, since when you RMB \u0026gt; Paste Relative References, it tends to blast away everything you had in there already. So instead, you need to copy the path to the parm someplace else, and paste it in.\nChannel referencing on the Font SOP can be tedious\nLinewriter uses a single-line string parameter, where this doesn\u0026rsquo;t seem to be an issue.\nMuch easier with single-line string parameters!\n2. Float values are over-precise This blog post goes over this more, but in short - a lot of times you see what should be a simple parm value like 0.025 being represented in a string parm as 0.025000000000000001. This is distracting, and wastes a lot of on-screen space.\nEach line of line-writer has a button that tries to \u0026ldquo;ftrimify\u0026rdquo; your line.\nftrimify line\nIt looks for each ch() or chs(), and wraps them up in an ftrim(). This helps cut down the numbers to max of six floating point digits. There is also a button under the Extra folder that will run it over all the lines at once.\nftrimify all button\nftrimify all in action\n3. Font artifacts Sometimes you\u0026rsquo;ll make a nice looking overlay, only to have a few B\u0026rsquo;s or D\u0026rsquo;s get their holes filled in. They look fine at the origin, but when parented to the camera, they look all wrong.\nI\u0026rsquo;m not sure what the exact cause is (some sort of precision thing I imagine), but the solution is simple: Pack up your Font SOP at the end. All the characters with holes will appear as they did before transforming (Linewriter does this per-line, as well as one final pack at the end).\nOther times, the artifacts are a direct result of the Font SOP itself. In this case, there is also an option to fix these holes, though it does decrease performance.\nHole fix option\n4. Limited coloring options If you have a few key lines that you want to stand out, you have to either make a few extra Font SOPs, or group the characters manually and color them later.\nLinewriter lets you set a base color for the whole block, and override per-line as needed.\n5. No background color options Look at Nuke\u0026rsquo;s Text node options and you\u0026rsquo;ll see a tab called Background. This is very useful for when your text is occluding some of your scene, and becomes difficult to read. Linewriter adds an optional background behind each line to make sure the text stands out.\nBackgrounds and Colors\n6. Performance In a single Font SOP, if even one of your referenced parameters is animated (time-dependent), it will cause the whole thing to recook each frame. For single lines, this isn\u0026rsquo;t a big deal. But with bigger, monolithic Font SOPs holding a whole slew of data for your overlay, this can be a little bit of a bottleneck.\nLinewriter optimizes this by splitting out lines that are time-dependent from the ones that aren\u0026rsquo;t, so only lines with animated data will recook.\nSplit time-dependent lines\nOther Features Transform into Camera If you provide a camera object, you can parent your text to a camera directly in SOPs from Linewriter.\nLook through the camera, select the Linewriter node, and hit enter in the viewport to activate the transform handle and move the text into place.\nParenting to a camera\nHelp Card Check the help card for extra info about each parameter\nEmbedded example setup Extra \u0026gt; Load Example Setup\nA demo setup is included to show how this node can be used\nLoad Example Setup button\nConstant Shader There is a simple constant shader inside that is applied to the all of the Linewriter geometry. This ensures that it doesn\u0026rsquo;t receive shadows, and that the text colors are as bright as possible in the viewport.\nInstallation Method 1: Houdini Packages Installation is simple with Houdini Packages.\nDownload the latest release here. You can clone the repo if you\u0026rsquo;d like instead.\nNavigate to your houdini user preferences folder and into the packages directory (if the packages folder does not exist, create it). $HOUDINI_USER_PREF_DIR/packages Copy the zip archive here and extract its contents. Move (or copy) the linewriter.json file to the parent directory $HOUDINI_USER_PREF_DIR/packages. Your packages folder should now look something like this: packages/ ├── linewriter │ ├── houdini18.5 │ │ └── hda │ │ └── jamesr_linewriter.hda │ └── houdini19.0 │ └── hda │ └── jamesr_linewriter.hda └── linewriter.json Launch Houdini. Method 2: Manual Installation Download the latest release here.\nYou can clone the repo if you\u0026rsquo;d like instead.\nNavigate to wherever you load digital assets from\n$HIP/otls, $HOUDINI_USER_PREF_DIR/hda, $HOUDINI_USER_PREF_DIR/otls etc.\nCopy jamesr_linewriter.hda from houdiniX.Y/hda into the location you chose in Step 2.\nLaunch Houdini.\nMethod 3: Install to Current Hipfile Launch Houdini. From the main title bar, select Assets \u0026gt; Install Asset Library. Navigate to wherever you downloaded the repo/zip archive and select the HDA for your version of Houdini from houdiniX.Y/hda/jamesr_linewriter.hda Select Install or Install and Create. ","permalink":"https://www.jamesrobinsonvfx.com/projects/linewriter/","summary":"Easily create lines of text geometry","title":"Linewriter"},{"content":"MPlay Batch Menu add-on for MPlay to quickly batch write sequences.\n🚀 View it on GitHub For the full overview and docs, check \u0026rsquo;em out here\n","permalink":"https://www.jamesrobinsonvfx.com/projects/mplay-batch/","summary":"Batch write sequences from MPlay","title":"MPlay Batch"},{"content":" Hipfile: jamesr_displayintermediateresultsandvisualizationgeoupdate.hiplc\nOverview One thing I didn’t realize until after I posted the last blog post/video is that you can actually add an output with a negative index! This output won’t show up as a port on the node.\nNegative Output Index\nWe can see this on the RBD Configure SOP. When we hit Enter in the viewport to enter the node’s Viewer State, we are switched to viewing the -1 output.\nRBD Configure Negative Output\nRBD Configure Contents\nWe can’t actually hook up to this output in the network editor, which could make this an excellent option since it causes less clutter!\nExample Let’s implement something similar ourselves. We\u0026rsquo;ll create a setup that takes some input geo and adds some point normals to it. It will have a couple of false-color visualization modes: Height and Normal.\nWhen we switch our Display menu, if we select anything except the \u0026ldquo;final result\u0026rdquo; of the node let\u0026rsquo;s switch to showing the -1 output in the viewport (which will only be outputting the visualization geo).\nOpen the hipfile and see the attached setup (or copy it from the screenshots):\nExample Overview\nExample Contents\nCreate an Ordered Menu Parameter called display with the following token/value pairs:\nMenu Tokens\nDon\u0026rsquo;t forget to link it up to your visualizer switch!\nSwitch (minus one)\nWe subtract 1 since we\u0026rsquo;re using index 0 of the menu to select our actual output geo, and if we didn\u0026rsquo;t subtract 1 our switch would be off by one.\nAdd a callback to the menu parameter that will switch to the -1 output whenever we select one of the visualizer options.\nkwargs[\u0026#34;node\u0026#34;].setOutputForViewFlag(-1 if kwargs[\u0026#34;script_value\u0026#34;] != \u0026#34;output\u0026#34; else 0) Menu Callback\nAnd that\u0026rsquo;s it!\n","permalink":"https://www.jamesrobinsonvfx.com/blog/display-intermediate-results-and-viz-geo-update/","summary":"A minor improvement on the previous post","title":"Display Intermediate Results and Viz Geo [Update]"},{"content":" Hipfile: jamesr_hdaguidegeometry.hip\nOverview One visualization option I didn’t mention in my previous post is Guide Geometry. HDAs allow you to select a node in your asset and have it show up in the viewport as a wireframe. Sometimes this is perfect and it’s all you need, other times it can be a bit limiting. That being said, here’s how you can use it!\nCheck out the video and hipfile above!\n","permalink":"https://www.jamesrobinsonvfx.com/blog/hda-guide-geometry/","summary":"Add a simple visualizer to your HDA using Houdini\u0026rsquo;s built-in Guide Geometry feature","title":"HDA Guide Geometry"},{"content":" Get the HDA\nSample Hipfile\nView it on GitHub Overview This node uses the Clip SOP to cut primitives whose user-specified point attribute value is outside a certain threshold. It\u0026rsquo;s one of my favorite little tools, and I really wanted to explore creating Viewer States in Houdini. I\u0026rsquo;m by no means a Python Viewer State expert, so keep that in mind when you\u0026rsquo;re poking around the code ;)\nAdjusting clip threshold\nUsing the Blast Sop with a group expression is very similar, but since it deletes points/prims entirely, you usually wind up with a steppy, geometric edge.\nSince this node uses the Clip SOP instead, primitives can be cut more accurately and the result can be a bit nicer. Often pairs well with a Delta Mush\nBlast SOP. A bit jaggy.\nClip by Attribute. Much smoother!\nAll the code is embedded on the node itself (help docs, viewer state, etc) but I\u0026rsquo;ve also got a copy in the repo for easy diffing / reference.\nViewer State Features Viewer State Info Panel\nClick to sample clipping threshold from a mesh Use your mouse\u0026rsquo;s scroll wheel* to interactively fine-adjust the clipping threshold Clip by a component of a vector attribute Hotkeys to cycle vector components, reset clipping threshold, etc. Viewport Info Panel HUD Help Card Hit Enter in the viewport to enter the Viewer State and check out the Info Panel HUD for more info about how to use the viewer state features.\n*A little buggy with some mice at the moment, like my Logitech MX Master\nCredit to Charles Trippe for teaching me this cool method for clipping stuff!\n","permalink":"https://www.jamesrobinsonvfx.com/projects/clip-by-attribute-sop/","summary":"Clip primitives by a user-specified attribute","title":"Clip by Attribute Sop"},{"content":" Hipfile: jamesr_displayintermediateresultsandvisualizationgeo.hip\nOverview If you\u0026rsquo;ve ever built an HDA in Houdini, you might have come across the following problem:\nHow can I switch between showing the final result and some visualization geo inside my HDA?\nDisplaying intermediate results or visualizing stuff inside an HDA can be a little tricky in Houdini, mainly since changing the Display Flag in a locked asset isn\u0026rsquo;t allowed, and oftentimes the built-in wireframe Guide Geometry option isn\u0026rsquo;t enough for the job.\nI\u0026rsquo;ve run into this online and in my own work, and wanted to share a couple of ways you can easily display intermediate steps or visualization geometry in the viewport without too much fuss!\nWe\u0026rsquo;ll cover three solutions:\nSimple Switch SOP controlled by an Ordered Menu Additional Output Additional Output + Output for View Flag Callback Feel free to follow along using the hipfile above.\nBefore We Get Started Recap Some Basics Whichever node has the Display Flag set on it is the one that shows up in the viewport. The result of the node that it\u0026rsquo;s on is passed through the first/leftmost output (when not using an Output SOP).\nMore info With no Output SOP, the Display and Render flags determine the output of your node.\nWhen using Output SOPs inside a subnet/HDA, the Display Flag is ignored, and the result that\u0026rsquo;s piped into the Output SOP (whose index is zero) is what shows up in the viewport.\nMore info Caption\nHDAs/Subnets can have multiple outputs when using the Output SOP.\nMore info Multiple Outputs\nYou can change the Output for View Flag to switch which output is shown in the viewport.\nMore info Output for View Menu\nDisplay Flag can not be moved inside of a locked HDA, even with a Python callback.\nMore info Permission Denied (Interface)\nPermission Denied (Python)\nnode = hou.node(\u0026#34;/obj/locked_asset/displayflagcallback\u0026#34;) node.node(\u0026#34;torus\u0026#34;).setDisplayFlag(True) Traceback (most recent call last): File \u0026#34;\u0026lt;console\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;/Applications/Houdini/Current/Frameworks/Houdini.framework/Versions/Current/Resources/houdini/python3.9libs/hou.py\u0026#34;, line 79 410, in setDisplayFlag return _hou.SopNode_setDisplayFlag(self, on) hou.PermissionError: Failed to modify node or parameter because of a permission error. Possible causes include locked assets, takes, product permissions or user specified permissions You could get even fancier than this tutorial using Python Viewer States, but we won\u0026rsquo;t be covering that here.\nExample Setup To demonstrate, we\u0026rsquo;ll be creating a super simple Voronoi fracturing HDA. The focus is definitely not on how this tool works, but how we can improve the user experience!\nBasic Example Setup\n\u0026ldquo;Intermediate Steps\u0026rdquo; / \u0026ldquo;Visualization Geometry\u0026rdquo;? I\u0026rsquo;ve mentioned the terms Intermediate Steps and Visualization Geometry twice now, but I should explain a bit more clearly what I mean in terms of the example setup that we\u0026rsquo;ll use for the rest of the tutorial.\nIntermediate Steps When your HDA wraps up a workflow that does a few things in order (like our example), it can be helpful to be able to see the result of each step. In this example, we\u0026rsquo;re building a basic fracturing HDA. For debugging purposes, it could be good to be able to inspect the noised-up volume and the scattered points. Creating these geometries is what I\u0026rsquo;m referring to as Intermediate Steps. They contribute to, but are not the final result.\nVisualization Geometry It could also be nice to see an exploded view of all our pieces with different colors assigned to them (for this example\u0026hellip;probably not that useful in practice, but let\u0026rsquo;s use it here as a demo!). Since this doesn\u0026rsquo;t really contribute to the final result at all and is just for debugging/inspection, I call it Visualization Geometry.\nSimple: Switch SOP and an Ordered Menu Parameter First up, we have the simplest method: We\u0026rsquo;ll use a Switch SOP to switch what our node outputs, and link it to an Ordered Menu Parameter.\nPros Simple to set up Cons Easy to forget and accidentally leave the menu on the wrong selection and output the wrong thing First, let\u0026rsquo;s create some Null SOPs to use as \u0026ldquo;anchors\u0026rdquo; for each thing we want to switch between. This helps keeps things clean, organized, and flexible.\nAnchor Nulls for each step\nNext we\u0026rsquo;ll plug all our nulls into the switch in the same order that we want to have their corresponding items in the dropdown menu.\nNulls plugged into switch\nFinal Result (Fractured Pieces) Noised-up Volume Points Exploded / Colorized Pieces Another common technique is to create an Object Merge for each Null and put the switch off to the side to reduce clutter, but I\u0026rsquo;ll keep just plugging the nulls straight into the switch for this example. Object Merges into a switch\nSwitch SOPs are controlled by an integer parameter, so we can use an Ordered Menu to control the switch index, since they are essentially integer parameters themselves but with a more descriptive interface.\nOrdered Menu linked to a Switch SOP\nCreating a Menu Parameter for a Switch. Right Click \u0026gt; Open in New Tab for full rez version\nCheck out this post for more info about how menus are evaluated.\nAdditional Output When you have one thing you\u0026rsquo;d like to visualize, a common technique is to add another Output SOP and connect it to your visualization geo. Whenever you want to view this visualization geo, you can just drop a Null SOP down, connect it to the extra output, and put the display flag on it (or use the Output for View Flag).\nPros Less prone to error - we aren\u0026rsquo;t changing the result of the primary output of the node We can flipbook the viz geo or view it side-by-side\u0026hellip;anything like that Cons Requires the user to drop another node just to see the viz geo, or switch the Output for View Flag themselves Data from this output might not really be useful elsewhere Could add clutter to your node if you already have many outputs Since we have another output now, we can keep the final result flowing through the first output, so our users won\u0026rsquo;t get tripped up by accidentally leaving the output to something that was only meant for visualization purposes.\nFor switching between multiple visualization items, we can have just one menu on our interface somewhere called \u0026ldquo;Visualization Output\u0026rdquo; or something, and that can control what comes through our extra output.\nVisualization menu\nFavorite: Output for View Flag Callback Let\u0026rsquo;s take the additional output method above one step further and make it a bit slicker. It\u0026rsquo;s kind of annoying to either make a Null each time you want to view the visualization output, or click through the Output for View RMB menu (especially if you haven\u0026rsquo;t setup hotkeys for that), so let\u0026rsquo;s add a short callback to the menu parameter and do it automatically!\nThis is my favorite method because there\u0026rsquo;s no risk of accidentally leaving a menu on the wrong thing and passing the wrong output (not that I\u0026rsquo;ve ever done this in production and kicked it to the farm\u0026hellip;). Also, it doesn\u0026rsquo;t require the user to muck around with creating another node just to see their visualization geo.\nMore info on Node Flags from the docs.\nPros Always passing through the same result from the primary/first output No need to put down any extra nodes, or know anything about how to change the Output for View Flag All the pros of the previous methods Cons Requires a little bit of Python Setup First, we\u0026rsquo;ll add another menu to control whether we\u0026rsquo;re displaying the final output geo (the fractured pieces) or the extra visualization geo.\nSecond Menu\nAnd let\u0026rsquo;s tighten up the two menus to make it a bit prettier:\nTighten it up\nOptionally, we could add a disable/hide when rule to hide the visualization menu when we\u0026rsquo;re not viewing the visualization. That\u0026rsquo;s up to you! This is where setting a menu token can be useful, since if we ever decide to change the order or this menu or add new stuff, we don\u0026rsquo;t have to update any disable/hide when rules if our menu indices changed.\nNext, we\u0026rsquo;ll add a parameter callback to this new menu that will switch the Output for View Flag for us when we change it.\nQuick Recap: What is a parameter callback? Whenever a user changes a parameter in the interface (or runs a hou.Parm.pressButton() with Python), Houdini runs whatever code is in the Callback Script field in the parameter\u0026rsquo;s Parameter Description from the Type Properties or Edit Parameter Interface window.\nCallback script location\nSee the SideFX docs on Parameter Callback Scripts for more info.\nWriting our Callback When writing parameter callback scripts in Python, we get access to a dict called kwargs that passes some super useful info about the parameter and its state.\nLet\u0026rsquo;s print the value of kwargs and see what\u0026rsquo;s in it:\nkwargs dict contents\n{ \u0026#39;node\u0026#39;: \u0026lt;hou.SopNode of type subnet at /obj/geo4/fracture\u0026gt;, \u0026#39;parm\u0026#39;: \u0026lt;hou.Parm display in /obj/geo4/fracture\u0026gt;, \u0026#39;script_multiparm_index\u0026#39;: \u0026#39;-1\u0026#39;, \u0026#39;script_value0\u0026#39;: \u0026#39;viz\u0026#39;, \u0026#39;script_value\u0026#39;: \u0026#39;viz\u0026#39;, \u0026#39;parm_name\u0026#39;: \u0026#39;display\u0026#39;, \u0026#39;script_multiparm_nesting\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;script_parm\u0026#39;: \u0026#39;display\u0026#39; } One key in particular stands out: script_value. This is the new value that the parameter was just set to. One gotcha with this is that in this dictionary, it always returns a string, and in this case it\u0026rsquo;s the token string we added when we created the menu. We should keep this in mind when we write the callback.\nMenu token/labels\nWe can use one of the following snippets for our callback:\n# In our case, we only have two menu items (0, 1) and two outputs kwargs[\u0026#34;node\u0026#34;].setOutputForViewFlag(kwargs[\u0026#34;parm\u0026#34;].evalAsInt()) or if we\u0026rsquo;d rather compare the string from the menu token:\nkwargs[\u0026#34;node\u0026#34;].setOutputForViewFlag(kwargs[\u0026#34;script_value\u0026#34;] == \u0026#34;viz\u0026#34;) Now whenever we switch this menu, the Output for View Flag is updated on our node, and we can switch between seeing the viz geo and our actual output!\nOne Step Further This is pretty good, but if we wanted we could take it another step further and instead of using two menus, flatten it down into one. We\u0026rsquo;re kind of doing a mix of the first method and the additional output method above.\nSingle Menu\nLet\u0026rsquo;s get rid of the second menu, and add an item called \u0026ldquo;Fractured Pieces\u0026rdquo; to index 0 of the Display menu. Now the menu has all the items in it, a lot like we had in the first example method.\nUpdate index zero\nUpdate the Switch Since our menu has one more element in it (the \u0026ldquo;final\u0026rdquo; output selection in index 0), we need to subtract 1 from the switch lookup.\nUpdate the switch index\nUpdate the Callback Finally, we\u0026rsquo;ll add a callback for this menu:\nUpdated Callback\nkwargs[\u0026#34;node\u0026#34;].setOutputForViewFlag(kwargs[\u0026#34;script_value\u0026#34;] != \u0026#34;output\u0026#34;) or\nkwargs[\u0026#34;node\u0026#34;].setOutputForViewFlag(kwargs[\u0026#34;parm\u0026#34;].evalAsInt() \u0026gt; 0) And that\u0026rsquo;s it! We can switch between our visualization geometry / intermediate step stuff from a single menu, but leave our actual output untouched!\nFinal Thoughts Housekeeping Label your outputs!\nThe Output for View Flag label in the Network Editor gets its name from the name of the Output SOP. Output for View Flag Label\nWhen you hover over an output port of an HDA, that label is set from the Type Properties dialog. Also, when this is set, the Output for View Flag label in the Network Editor will use this instead of the Output node\u0026rsquo;s name.\nOutput Label (Type Properties)\nColor your inputs/outputs if you like\nInput and output ports take on the same color as their corresponding nodes inside\nSwitch SOPs and Bitfields from Button / Icon Strips Another post coming soon!\n","permalink":"https://www.jamesrobinsonvfx.com/blog/display-intermediate-results-and-viz-geo/","summary":"Different methods for switching between visualization geo in an HDA or subnet","title":"Display Intermediate Results And Visualization Geo in an HDA"},{"content":"Menu Parameters \u0026amp; Evaluation Results I can never remember off the top of my head when a menu parameter is going to evaluate the token string, or an integer, or a string representation of an integer without first doing a quick little check in the Python Shell\u0026hellip;so here\u0026rsquo;s a table that should help future James and maybe some other folks as well. Each test was done with the parameters set to use a Normal menu, with the tokens item0, item1\u0026hellip;\nParameter Type hou.Parm.eval() hou.Parm.evalAsString() hou.Parm.evalAsInt() ch() chs() kwargs[\u0026quot;script_value\u0026quot;] Ordered Menu 1 \u0026ldquo;item1\u0026rdquo; 1 1 \u0026ldquo;item1\u0026rdquo; \u0026ldquo;item1\u0026rdquo; String \u0026ldquo;item1\u0026rdquo; \u0026ldquo;item1\u0026rdquo; TypeError 0 \u0026ldquo;item1\u0026rdquo; \u0026ldquo;item1\u0026rdquo; Integer 1 \u0026ldquo;1\u0026rdquo; 1 1 \u0026ldquo;1\u0026rdquo; \u0026ldquo;1\u0026rdquo; Cells with formatting like 0, and 1 are integer types. Cells in double quotes \u0026quot; are string types.\nOverview Houdini offers a few ways to both create and evaluate dropdown menu parameters.\nThe way you configure these menu parameters affect how they get evaluated in different contexts (hscript, Python, parameter callbacks, etc.). Let\u0026rsquo;s take a look at what that means, and come up with a quick reference table that we can use when debugging or creating new interfaces.\nHipfile: jamesr_evaluatingmenuparameters.hiplc\nMenu Parameter Types Typical dropdown menu\nWhat\u0026rsquo;s a menu made of? Houdini menus are made up of item/label pairs.\nItem/Label Pairs\nLabel Labels are the \u0026ldquo;nice names\u0026rdquo; that the user sees in the dropdown.\nUsing Python, you can get a list of a menu parameter\u0026rsquo;s labels with\nhou.parm(\u0026#34;/obj/geo1/null1/greetings\u0026#34;).menuLabels() (\u0026#39;Hi\u0026#39;, \u0026#39;Hallo\u0026#39;, \u0026#39;Kia ora\u0026#39;, \u0026#39;Hej hej\u0026#39;, \u0026#39;こんにちは\u0026#39;) If you ever want to get the label of the currently selected menu item, try this:\nparm = hou.parm(\u0026#34;/obj/geo1/null1/greetings\u0026#34;) parm.menuLabels()[parm.evalAsInt()] \u0026#39;Hallo\u0026#39; Item (Token) A Menu Item is the internal name used by Houdini. You can optionally specify a token for each menu item which can be used for setting and evaluating the menu as a string, and for use with disable/hide when rules.\nJust because you put something as the token, doesn\u0026rsquo;t mean that\u0026rsquo;s always what you\u0026rsquo;ll get when you evaluate it (see the table above).\nUsing Python, you can get a list of a menu parameter\u0026rsquo;s items/tokens using:\nhou.parm(\u0026#34;/obj/geo1/null1/greetings\u0026#34;).menuItems() (\u0026#39;hi\u0026#39;, \u0026#39;hallo\u0026#39;, \u0026#39;kiaora\u0026#39;, \u0026#39;hej\u0026#39;, \u0026#39;konnichiwa\u0026#39;) Ordered Menu In general, most of the menu parameters I come across (and create) use the Ordered Menu parameter type. This parameter type creates the classic dropdown that you\u0026rsquo;ve likely seen countless times:\nTypical dropdown menu\nTypical dropdown menu settings\nThese can be created directly in the Type Properties / Edit Parameter Interface UI by either explicitly specifying a list of token/label pairs\nConfiguring and Ordered Menu parameter in the Edit Parameter Interface window\nor more dynamically through a Python parameter menu script.\nAn example of Python Parameter Menu Script\ngreetings.json greetings.json\n{ \u0026#34;greetings\u0026#34;: [ {\u0026#34;language\u0026#34;: \u0026#34;english\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;hi\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Hi\u0026#34;}, {\u0026#34;language\u0026#34;: \u0026#34;german\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;hallo\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Hallo\u0026#34;}, {\u0026#34;language\u0026#34;: \u0026#34;te reo\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;kiaora\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Kia ora\u0026#34;}, {\u0026#34;language\u0026#34;: \u0026#34;swedish\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;hej\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Hej hej\u0026#34;}, {\u0026#34;language\u0026#34;: \u0026#34;japanese\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;konnichiwa\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;こんにちは\u0026#34;} ] } For more info on generating menus with Python:\nGenerating a menu from attributes\nParameter Menu Scripts\nQuick Menu Script List\nString or Integer Parameter with \u0026ldquo;Use Menu\u0026rdquo; Enabled Another common place to use menus are String and Integer parameter types.\nThese menus are often used to help populate a field, for instance when selecting several attributes to get rid of in the Attribute Delete SOP.\nAttribute Delete SOP Menu with attributes expanded\nA regular String parameter type can be made to use a menu by enabling the following toggle on the right side of the Type Properties / Edit Parameter Interface window:\nUse Menu toggle\nWhen using the Normal option, the menu will appear just like the ordinary Ordered Menu parameter type. The other two common options are Replace and Toggle - these will add a small mini-menu to the right of the string/int parameter from which you can select and populate the string/int field. Those are the styles that are most familiar from nodes like Attribute Delete etc.\nWhy would I ever use the \u0026ldquo;Normal\u0026rdquo; mode if I\u0026rsquo;m using a string or int parameter? Can\u0026rsquo;t I just use an Ordered Menu? Usually an Ordered Menu is just fine - but one advantage is explicitness. If you want to make sure your menu always returns a string when using HOM\u0026rsquo;s hou.Parm.eval(), you can create a String parameter, enable Use Menu, and keep it as Normal (Menu Only, Single Selection). Whenever someone evaluates the parameter with hou.evalParm(\u0026quot;/obj/geo1/null1/mymenuparm\u0026quot;), they will get a string back which is not the case with the standard Ordered Menu type (which would need hou.Parm.evalAsString(), even if your token looks like a string).\nTest Cases For testing, I\u0026rsquo;m using the following menu parameters:\nOrdered Menu String Parameter with Normal menu enabled Integer Parameter with Normal menu enabled Menus on the Parameter Interface\nThey each have different labels, but the menu items/tokens are all the same: item0, item1\u0026hellip;\nThe results in the tables below were gathered when the menus were changed to their second dropdown item (item1).\nSee the hipfile above to check it out yourself.\nMenu testing interface from hipfile\n`hou.Parm.eval()` hou.Parm.eval() value = parm(\u0026#34;orderedmenu\u0026#34;).eval() return f\u0026#34;{value} {type(value)}\u0026#34; Parameter Type hou.Parm.eval() Type Ordered Menu 1 int String item1 str Integer 1 int `hou.Parm.evalAsString()` hou.Parm.evalAsString() value = parm(\u0026#34;orderedmenu\u0026#34;).evalAsString() return f\u0026#34;{value} {type(value)}\u0026#34; Parameter Type hou.Parm.evalAsString() Type Ordered Menu item1 str String item1 str Integer 1 str `hou.Parm.evalAsInt()` hou.Parm.evalAsInt() value = parm(\u0026#34;orderedmenu\u0026#34;).evalAsInt() return f\u0026#34;{value} {type(value)}\u0026#34; Parameter Type hou.Parm.evalAsInt() Type Ordered Menu 1 int String TypeError Integer 1 int `ch()` ch() ch(\u0026#34;orderedmenu\u0026#34;) Parameter Type ch() Type Ordered Menu 1 int String 0 int Integer 1 int `chs()` chs() chs(\u0026#34;orderedmenu\u0026#34;) Parameter Type chs() Type Ordered Menu item1 str String item1 str Integer 1 str `kwargs[\"script_value\"]` kwargs[\u0026quot;script_value\u0026quot;] value = kwargs[\u0026#34;script_value\u0026#34;] hou.ui.displayMessage(f\u0026#34;kwargs[\u0026#39;script_value\u0026#39;] = {value}\\n\\n{type(value)}\u0026#34;) Parameter Callback (Python)\nParameter Type kwargs[\u0026quot;script_value\u0026quot;] Type Ordered Menu item1 str String item1 str Integer 1 str When implementing parameter callbacks, Houdini gives us access to a Python dictionary named kwargs filled with useful info about the parameter. One of those keys is called script_value, which according to the docs is equivalent to kwargs[\u0026quot;parm\u0026quot;].eval() (see above - this isn\u0026rsquo;t quite always the case, especially when it comes to int/float parameters, since it always seems to return a string).\nSee Also Parameter Callback Scripts\nFinal Thoughts Ordered Menus and String Parameters can be set using their tokens like so:\nhou.parm(\u0026#34;/obj/geo1/null1/orderedmenu\u0026#34;).set(\u0026#34;item1\u0026#34;) When an integer parm using a Normal menu that has tokens is evaluated as a string, it will not return the token, but rather a string representation of the selected index.\nYou cannot set an integer menu parameter by its token like you can with a string parameter / ordered menu unless the token you\u0026rsquo;re trying to set it to is a string representation of a numerical value, like \u0026quot;1000\u0026quot;, \u0026quot;42\u0026quot; etc.\nUse Token as Value This reply from SESI on the SideFX Forums describes well what Use Token as Value does.\nWhen you have Use Token as Value enabled on an integer parameter with a menu (or an Ordered Menu), and your tokens are string representations of numbers like \u0026quot;1000\u0026quot; or\u0026quot;42\u0026quot;, instead of evaluating to the menu index as usual, Houdini will try to use that value instead.\nFor instance, if our integer parameter has the following menu:\nToken Label item0 Int Label 0 item1 Int Label 1 42 Forty Two and we have Use Token as Value disabled, calls like hou.Parm.eval() and ch() will evaluate to the selected menu index 2\nUse Token and Value disabled\nOnce we turn on Use Token as Value, we get 42\nUse Token as Value enabled\nSee it in use for real on the Vellum Constraints node\u0026rsquo;s stretchstiffnessexp parameter.\n","permalink":"https://www.jamesrobinsonvfx.com/blog/evaluating-menu-parameters/","summary":"Explore the results of evaluating menu parameters with various methods","title":"Evaluating Menu Parameters"},{"content":" Hipfile: jamesr_executingpythonfromstring.hiplc\nOverview Sometimes you just want to run some python code, but don\u0026rsquo;t want to run line-by-line in the Python Shell, can\u0026rsquo;t be bothered to create a shelf tool, and don\u0026rsquo;t need to run over geometry (so the Python SOP is out). Luckily, it\u0026rsquo;s really easy create a simple preset that lets us run some Python code from a string parameter on any node.\nThis is useful for creating small scripts to run in your scene, debug stuff, prototype some code, and even for creating code for parameter callbacks on the fly without needing to write your code to disk, or embed into an HDA.\nThis method uses Python\u0026rsquo;s exec function, and can be used to run any arbitrary string as code. Use with caution\u0026hellip;\nSetup Start off by creating a Null Object. This is where we\u0026rsquo;ll add our parameters.\nNull SOP\nMake all the current parms invisible by selecting them, and toggling the Invisible checkbox. We don\u0026rsquo;t need to see them.\nHide existing parameters\nAdd our own parameters and give them nice names and labels. We only need two:\nLabel: Execute Name: execute Type: Button Label: Code Name: code Type: String Hide existing parameters\nCurrently, the interface is pretty basic and not something that would be very comfortable writing code in!\nBasic parameters\nWe can make the string parameter a bit roomier by modifying its Parameter Template here:\nModify string parameter\nEnable Multi-line String Set the Language to Python Setting the language to Python doesn\u0026rsquo;t really do anything special, aside from giving us some nice syntax hints and highlighting in the string input area.\nPython string parameter\nNice, looking a lot better! Now we just need to hook it all up so that when we press the button, the code executes. We do this by adding a Callback to the button we created.\nThe callback code for this one is simple:\nexec(kwargs[\u0026#34;node\u0026#34;].parm(\u0026#34;code\u0026#34;).evalAsString()) Add callback\nMake sure to set the callback language to Python if it isn\u0026rsquo;t set already! You can tell by the icon to the right of the Callback Script parameter.\nAnd that\u0026rsquo;s it! Pressing the Execute button works just as a expected and prints our message to the shell.\nShell output\nTo finish it off, we can store this as a preset so that it\u0026rsquo;s super quick to set up when we need it:\nSave preset\nSave preset dialog\nA Quick Detour: kwargs Now kwargs is a whole topic in itself (see the documentation)! Basically, whenever you\u0026rsquo;re running code on a node in Houdini, whether through a callback, an Action Button, a menu script, an OnCreated script \u0026hellip; and so on, Houdini usually passes you a really useful object called kwargs. kwargs generally stands for Keyword Arguments, and is a simple Python dictionary with some key/value pairs that can be really useful to you. I don\u0026rsquo;t want to make this a post about kwargs, but just so we can understand it a little better, let\u0026rsquo;s quickly erase the callback code that\u0026rsquo;s currently in there, and replace it with:\nprint(kwargs) Checking the python shell, we can see that kwargs gives us access to the following info:\n{\u0026#39;node\u0026#39;: \u0026lt;hou.ObjNode of type null at /obj/null1\u0026gt;, \u0026#39;parm\u0026#39;: \u0026lt;hou.Parm execute in /obj/null1\u0026gt;, \u0026#39;script_multiparm_index\u0026#39;: \u0026#39;-1\u0026#39;, \u0026#39;script_value0\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;script_value\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;parm_name\u0026#39;: \u0026#39;execute\u0026#39;, \u0026#39;script_multiparm_nesting\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;script_parm\u0026#39;: \u0026#39;execute\u0026#39;} so when we called kwargs[\u0026quot;node\u0026quot;] above, we used the dictionary Houdini gave us for free to find the node that the parameter who was running the callback belongs to. This is generally a lot more reliable than using other methods such as hou.pwd() to find the current node. So use kwargs if it\u0026rsquo;s available!\nAdvanced: Complex Callbacks on the Fly Now that we know how to run code on a node, and have some idea of what we get from kwargs, it\u0026rsquo;s possible for us to actually write some more complicated code in a string parameter, and use it to run a callback that does something else.\nThe interesting part about this is that when we execute our code with the snippet above:\nexec(kwargs[\u0026#34;node\u0026#34;].parm(\u0026#34;code\u0026#34;).evalAsString()) the kwargs dictionary is made available to us in our code block!\nkwargs in parm\nIf we look closely, we can see that the 'parm_name' key\u0026rsquo;s value is 'execute', meaning that the kwargs dictionary was passed through from our button! This means we can write code in our string parameter and run it like a callback just like you can do on HDAs using the PythonModule script section! This can be extremely useful for creating scripts on the fly that run over multiple items in multiparm blocks. I\u0026rsquo;ll include an example of that in the hipfile.\nAdvanced mode\nHopefully you enjoyed this, and thanks for reading!\n","permalink":"https://www.jamesrobinsonvfx.com/blog/executing-python-code-from-a-string-parameter/","summary":"Create a preset on a Null that lets you run Python code from it","title":"Executing Python Code From a String Parameter"},{"content":"Overview In the past few releases, SideFX has been going pretty hard with the multi-output workflow style nodes, particularly with Vellum and RBD SOPs.\nThe most common way to view the outputs of these nodes is to just drop a null down and display it.\nDrop a Null\nThis can be useful for other things, but sometimes you just want a quicker way, with less clutter!\nOutput for View RMB \u0026gt; Flags \u0026gt; Output for ViewOutput for View Flag\nRight-click menu to the rescue! You can actually set the output you want to view by changing a flag from the menu.\nThis will not affect the actual output result of the node! This is important to note, because it only affects the display, not what is actually being passed through the outputs.\nAssigning a Hotkey Since this option is in a menu (like a lot of other useful options!), we can actually bind this to a hotkey.\nHotkey Editor\nOpen the hotkey editor Edit \u0026gt; Hotkeys\nSearch for Set View Output Assign a hotkey for outputs 1 - 4 On Linux/Windows, I find that Ctrl + Alt + 1 (1 through 4) works nicely.\nThis post was written on a MacBook, so here it’s just Option + Cmd + 1-4\nNow, changing the displayed output is as easy as selecting the node and cycling through your new hotkeys!\nBonus: Python If you\u0026rsquo;re interesting in doing something scripty with this, you can use the following snippet to change the output:\n# Outputs are a zero-based index node = hou.node(\u0026#34;/obj/geo1/vellumtetrahedral\u0026#34;) node.setOutputForViewFlag(1) ","permalink":"https://www.jamesrobinsonvfx.com/blog/multi-output-display-hotkeys/","summary":"Quickly switch the display for nodes with multiple outputs (Vellum, Split, RBD, etc.) without a Null","title":"Multi-Output Display Hotkeys"},{"content":"Template repo for creating simple (or not so simple) Houdini Packages.\nView it on GitHub Overview This repo is meant to be a quick jumping off point for creating a Houdini package. You likely won\u0026rsquo;t need everything in here, but several common files and folders have been included as a good start.\nGetting Started Create a repository from this template\nCreating a repo from a template\nClone your new repository to your local machine\ngit clone git@github.com:jamesrobinsonvfx/demo_tool.git Open the repository and run ./initialize.py (See below for extra use instructions)\nStart building your tool!\nZip it up and share it with others (Optional)\nRun the following to create a .zip archive without any of the extra git fluff (See the included .gitattributes file for a list of excluded files)\ngit archive --format zip --output ../demo_tool.zip main If you\u0026rsquo;d like to do an actual release, read about how to do that on the GitHub docs. You\u0026rsquo;ll be able to add your .zip archive as part of the release links.\nYou can tell people to grab it by pointing them to\nhttps://github.com/jamesrobinsonvfx/demo_tool/releases/latest/download/demo_tool.zip Installing Your Package At some point, you\u0026rsquo;ll want to install your package into a Houdini session for everyday use and testing.\nIn order for Houdini to be able to include your tools in a session, it needs to be able to find them. Houdini looks in a set of paths and locations and loads in stuff that it finds along the way. Commonly, these would be things like Python libraries, HDAs, custom shelves, etc. You could just manually copy the contents of each of these to their respective folders (python2.7libs, hda, toolbar\u0026hellip;), but keeping track of all that can become a nightmare! With Houdini Packages, you can keep all that stuff together in one location, and with a specially formatted package .json file, you can tell Houdini where to look for it.\nThere\u0026rsquo;s a multitude of ways you can configure your packages to load. I highly recommend visiting the Houdini Packages documentation for more detailed info.\nOutlined below are two favorite ways of setting up and loading packages. Package .json files can be placed in any packages folder within a Houdini Location.\nFor studio-wide tools, that\u0026rsquo;s usually best located at your facility\u0026rsquo;s $HSITE.\nFor single users you\u0026rsquo;ll probably want to use your $HOUDINI_USER_PREF_DIR if you don\u0026rsquo;t have $HSITE set up. I will be using $HOUDINI_USER_PREF_DIR to make it easy to follow along.\nMethod 1: Packages live in the packages directory With this method, package folders and their .json package files live directly inside $HOUDINI_USER_PREF_DIR/packages.\nHoudini will not automatically search for .json files inside of subfolders within the packages directory.\nSetup Assuming your package is called demo_tool.\nCopy your Houdini Package folder to $HOUDINI_USER_PREF_DIR/packages/demo_tool Copy demo_tool.json from $HOUDINI_USER_PREF_DIR/packages/demo_tool to $HOUDINI_USER_PREF_DIR/packages Your $HOUDINI_USER_PREF_DIR directory structure should now resemble:\nhoudini18.5 └── packages/ ├── some_other_package/ │ ├── houdini18.5/ │ └── some_other_package.json ├── demo_tool/ │ ├── houdini18.5/ │ └── demo_tool.json ├── some_other_package.json └── demo_tool.json demo_tool.json can be quite simple:\n{ \u0026#34;path\u0026#34;: \u0026#34;$HOUDINI_PACKAGE_PATH/demo_tool/houdini18.5\u0026#34; } path is a shorthand keyword we can use to insert a location to the $HOUDINI_PATH.\nWhen used in a package .json file, the $HOUDINI_PACKAGE_PATH variable refers to the location of the package that is currently being read.\nThere are certain conditional statements (if/then) we can add to load different folders based on the Houdini version. See the actual houdini_package_template.json file for a more detailed package definition that does that.\nMethod 2: Packages live somewhere else It\u0026rsquo;s not uncommon to have a separate location on disk that holds 3rd party tools. In this case, we can dynamically add locations to tell Houdini to search in using the package_path keyword.\nThis this scenario, we have a packages folder located inside a known Houdini location, like $HOUDINI_USER_PREF_DIR. There is just one .json file inside. Its job is to point to other places where packages might live:\nhoudini18.5 └── packages/ └── packages.json { \u0026#34;env\u0026#34;: [ { \u0026#34;STUDIO_TOOLS\u0026#34;: \u0026#34;/prod_server/studio_tools\u0026#34; } ], \u0026#34;package_path\u0026#34;: [ \u0026#34;$STUDIO_TOOLS/cool_solver\u0026#34;, \u0026#34;$STUDIO_TOOLS/demo_tool\u0026#34;, \u0026#34;$STUDIO_TOOLS/qlib\u0026#34;, ] } Elsewhere on disk, we have a folder called studio_tools, filled with 3rd party Houdini Packages.\nprod_server └── studio_tools/ ├── cool_solver/ ├── demo_tool/ ├── qlib/ ├── render_engine/ └── some_other_package/ Each Houdini Package keeps its [package_name].json file inside. No need to move/copy it like Method 1.\n{ \u0026#34;path\u0026#34;: \u0026#34;$HOUDINI_PACKAGE_PATH/houdini18.5\u0026#34; } This method can be a great way to keep a bunch of 3rd party tools organized. It also makes it easy to programmatically add/remove packages, or even have multiple locations, such as a set of \u0026ldquo;production\u0026rdquo; packages and another set of \u0026ldquo;experimental\u0026rdquo; or \u0026ldquo;dev\u0026rdquo; packages.\nAs you can see, both ways have their pros and cons. And these certainly are not the only possible configurations!\nCaveats If you notice that HDAs/OTLs aren\u0026rsquo;t loading, but everything else in your package is, you might need to explicitly set $HOUDINI_OTLSCAN_PATH. While this shouldn\u0026rsquo;t be necessary, I\u0026rsquo;ve found that some tools/wrappers can block OTLs being loaded from custom additions to $HOUDINI_PATH. Setting this environment variable in your package is pretty straightforward:\n{ \u0026#34;path\u0026#34;: \u0026#34;$DEMO_TOOL_INSTALL_DIR\u0026#34;, \u0026#34;env\u0026#34;: [ { \u0026#34;DEMO_TOOL_INSTALL_DIR\u0026#34;: [ { \u0026#34;houdini_version \u0026gt;= \u0026#39;18.0\u0026#39; and houdini_version \u0026lt; \u0026#39;18.5\u0026#39;\u0026#34;: \u0026#34;$HOUDINI_PACKAGE_PATH/demo_tool/houdini18.0\u0026#34; }, { \u0026#34;houdini_version \u0026gt;= \u0026#39;18.5\u0026#39; and houdini_version \u0026lt; \u0026#39;19.0\u0026#39;\u0026#34;: \u0026#34;$HOUDINI_PACKAGE_PATH/demo_tool/houdini18.5\u0026#34; } ] }, { \u0026#34;HOUDINI_OTLSCAN_PATH\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;$DEMO_TOOL_INSTALL_DIR/hda\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;append\u0026#34; } } ] } This used to be included in the template, but this should be more of an edge case, so it has been removed.\nTools for Different Houdini Versions Every year, SideFX releases a new minor version of Houdini (18.0, 18.5, etc.). Sometimes they make pretty sweeping changes that can cause your tools not to work between versions.\nRather than fighting this and trying to make your tool work for every release of Houdini, you can just create a new version of your tool to work with the next release.\nThe easiest way to release your stuff for a new version is to simply copy your latest houdiniX.Y folder, update the number, and see if it works! For example, when Houdini 19.0 is released, you can do the following:\nCopy houdini18.5 and all of its contents\nPaste it\nRename houdini18.5 to houdini19.0\nUpdate the demo_tool.json file to load from that location when using houdini19.0\n{\u0026#34;houdini_version \u0026gt;= \u0026#39;19.0\u0026#39; and houdini_version \u0026lt; \u0026#39;19.5\u0026#39;\u0026#34;: \u0026#34;$HOUDINI_PACKAGE_PATH/demo_tool/houdini19.0\u0026#34;} Alternative: Per-build package In some cases, especially for tools that might depend on specific production builds (render engines, custom HDK nodes), it might be important to have a unique release of your tool per build.\nIn this case, instead of having a houdini18.5 folder, you might have multiple folders named for each build number, ie. 18.5.496, 18.5.593\ndemo_tool ├── 18.5.496/ └── 18.5.596/ ├── dso/ └── hda/ ... Instead of writing conditional statements for every single build, there\u0026rsquo;s actually an undocumented shorthand we can use:\n{ \u0026#34;path\u0026#34;: \u0026#34;$HOUDINI_PACKAGE_PATH/${HOUDINI_VERSION}\u0026#34; } Another Alternative: Who cares about the build version? It\u0026rsquo;s not actually necessary to have separate versions of your tool for different Houdini versions. As long as you have properly named folders that follow the structure of $HFS/houdini.\ndemo_tool ├── hda/ │ └── studio_cooltool.hda └── python3.7libs/ └── package_utils.py { \u0026#34;path\u0026#34;: \u0026#34;$HOUDINI_PACKAGE_PATH/demo_tool\u0026#34; } This also works, but remember it could be a little trickier to maintain across Houdini versions.\nTemplate Contents This Houdini Package structure mimics the one you\u0026rsquo;d find in $HH (aka $HFS/houdini). This makes it easy for Houdini to pick up its contents. When you tell Houdini to add a directory to the $HOUDINI_PATH, any folders that match the name/structure found in $HH will be made available to you in your houdini session.\n$HFS is the location of the Houdini installation. You can type this in a File Browser from within Houdini to see exactly where this is.\nIf you ever want to add more folders inside, check out the contents of $HH.\nFor example, if you wanted to add some testing geometry to your package, refer to $HH for where that might be (probablygeo). Or maybe you want to extend the Gear Menu in the parameter editor with some of your own custom functionality. In $HH you see that there is a ParmGearMenu.xml file. To mimic the structure, you would simply add your own ParmGearMenu.xml file right inside the houdini18.5 directory. I think you get the point!\nSeveral common directories and files have been included. Any of the files/folders inside houdiniX.Y can be removed if they aren\u0026rsquo;t needed for your project. At a bare minimum, like a package with a single HDA, your package structure should probably look something like this:\ndemo_tool ├── houdini18.5/ │ └── hda/ │ └── jamesr_cooltool.hda └── demo_tool.json Package .json This is the file that tells Houdini how to load your tool.\nHoudini will search folders called packages for .json files. These .json files can be used to set environment variables when Houdini launches, and add things to the $HOUDINI_PATH so that they are made available to you in the Houdini session.\nThink of it like houdini.env, but easier to deal with.\nhoudiniX.Y Directory that mirrors $HFS/houdini. By naming it after each minor release, we can easily maintain our tools for forward and backward compatibility.\npythonX.7libs With Python 3 being the current VFX standard, and more and more DCCs supporting it, python3.7libs has been added to this template as a starting point. A few things to note:\nYou can have both python2.7libs and python3.7libs in the same project. Depending on your Houdini installation, if you\u0026rsquo;re launching with a Python 3 build, Houdini will use the packages/modules found in python3.7libs.\nPython 3 does not necessary require an __init__.py file like Python 2.7 does.\nPackages You might want a whole Python package that you can import, so one named after the Houdini package has been included. Modules If your Houdini package only needs a single python module (.py file), you can delete the folder inside pythonX.7libs, and simply put your python file directly in there. MainMenuCommon.xml Not every tool needs a dropdown menu (nor should they all get one!), but included is a simple template example for where it would need to go, as well as some boilerplate XML that creates a menu named after your package.\ntoolbar houdiniX.Y/toolbar is where any .shelf files live. Some packages really benefit from having artist-friendly shelf tools to help make using your tools a bit easier. Inside is some more boilerplate XML to setup a simple shelf named after your package.\nRemember if you add any tools to you custom shelf in Houdini, make sure to set the save location to your shelf! Unfortunately, Houdini does not remember your save choices, and will default to saving to the default shelf in your preferences directory!\nSaving a shelf tool\nhelp/nodes Help cards for any of your tools/assets can live either directly on the assets themselves, or someplace on disk. Included is the structure for where you need to store custom help card docs, as well as a basic starting template.\nTake note of the naming scheme- if you\u0026rsquo;re following SideFX\u0026rsquo;s recommended naming and versioning scheme, you\u0026rsquo;ll probably have tools named like this:\njamesr::inspectnodedata::1.00 where jamesr is the namespace. The help file for such a node would be called\njamesr--inspectnodedata.txt initialize.py This script runs a short command-line wizard that lets you set the package name and title. It should be run before making any additions/changes to the template.\nmacOS / Linux\n./initialize.py Windows\npython initialize.py If you prefer to do it in one line, you can add the package name and title as command-line arguments:\n./initialize.py [title] [package_name] ie.\n./initialize.py \u0026#34;Demo Tool\u0026#34; demo_tool Initialization script\nYou could totally just manually hunt for everything called houdini_package_template, and the tags {% raw %}{% package_name %}{% endraw %}, {% raw %}{% Package Title %}{% endraw %} and {% raw %}{% PACKAGE_NAME_UPPER %}{% endraw %}, and replace them manually. Or you can use the script (just use the script).\n","permalink":"https://www.jamesrobinsonvfx.com/projects/houdini-package-template/","summary":"Template repo for creating simple (or not so simple) Houdini Packages","title":"Houdini Package Template"},{"content":" View it on GitHub Overview When you write a wrangle that you just love and want to share it with the world (or your future self), why go through all the hassle of opening Firefox, navigating to your Gists page, logging in to GitHub, copying and pasting the code (gasp!), and pressing the Create Gist button? Never mind choosing a filename, setting the syntax highlighting, and coming up with a description for it! Did you see all those words with -ing at the end? That\u0026rsquo;s all stuff you have to do! What if you could just have one button that does all that stuff for you? You could potentially save valuable seconds of your life\u0026hellip;\nThat\u0026rsquo;s where [Wrangle to Gist]({{ site.socials.github }}/{{ page.repo }}) comes in. It\u0026rsquo;s a simple script that gets added to any parameter in Houdini that deals with snippets (chunks of code), and allows you to quickly post that snippet straight to your [Gist Feed]({{ site.socials.gist }}). View the rest of the features below.\nInstallation Houdini Packages Download the latest release here.\nOptionally, you can clone this repo if you\u0026rsquo;d like instead. Navigate to your houdini user preferences folder and into the packages directory (if the packages folder does not exist, create it).\n$HOUDINI_USER_PREF_DIR/packages Copy the zip archive here and extract its contents.\nMove (or copy) the wranglegist.json file to the parent directory $HOUDINI_USER_PREF_DIR/packages. Your packages folder should now look something like this:\nPackages folder\nLaunch Houdini\nManual Installation If you prefer not to use Houdini packages for whatever reason, you can manually copy the files to any Houdini location ($HSITE, $HOUDINI_USER_PREF_DIR) or anywhere on your $HOUDINI_PATH.\nParmMenu.xml should live at the root. ie if you\u0026rsquo;re moving these files into your user prefs folder, it should live right inside the houdini18.5 folder. Copy the module wranglegist.py to python2.7libs or python3.7libs (depending on your Houdini installation version) Setup 1. Create a Personal Access Token Personal Access Token\nIn order to push gists to your GitHub account, you need to create a personal token to use. It is pretty straightforward, and well-explained on GitHub\u0026rsquo;s page here.\nFor the Scopes section, you can just select gists.\nScopes\n2. Where to put the token This tool will look for your personal access token inside your home folder.\nLinux / Mac\n~/gist_personal_access_token %UserProfile%\\gist_personal_access_token Create an empty file in your home folder and call it gist_personal_access_token On the first line, put your GitHub Username. For me, this would be jamesrobinsonvfx On the second line, paste in the token that github created for you in the previous step. Your ~/gist_personal_access_token file should now look like the following: jamesrobinsonvfx ghp_eeGRRdh7ESHGdfke3GJKEoC46rDmg And that\u0026rsquo;s it!\nDon\u0026rsquo;t share your access token with anyone! This one is some gibberish, but close to what one would actually look like.\nFeatures This menu item does one thing: push the snippet to your Gists feed! There are a couple extra features to note:\nSuggested filename will come from whatever the node is called (opname(\u0026quot;.\u0026quot;)), unless the node name is the default one from Houdini (ie. pointwrangle).\nDescription field is left blank, unless your snippet\u0026rsquo;s first line is a comment (// or /* for C-style languages, # or \u0026quot;\u0026quot;\u0026quot; or ''' for Python)\nYou can choose from a few supported extensions:\n.h .vfl .py .ocl Please note that .vfl extensions aren\u0026rsquo;t recognized by GitHub/Gist, so the format highlighting won\u0026rsquo;t be there. That\u0026rsquo;s why for Vex wrangles I typically use .h to get some nice color variation. It\u0026rsquo;s close.\nContext Any parameter named snippet, code or python will have this option in its Right Click menu.\nUsage Example usage\n","permalink":"https://www.jamesrobinsonvfx.com/projects/wrangle-to-gist/","summary":"Post code snippets to your Gist feed from within Houdini","title":"Wrangle to Gist"},{"content":" Hipfile: jamesr_attributebindings.hiplc\nBasics Let\u0026rsquo;s build a super simple setup that applies randomness to an attribute on some points. The user will specify which attribute they want to write to. We also want the user to be able to scale the points by any attribute they specify without changing any of the code.\nSo the first thing we will need is some logic to randomize a value, and write it out. In this case, let\u0026rsquo;s start with pscale so we can see what\u0026rsquo;s happening.\nScale some points\nfloat r = rand(i@ptnum); f@pscale *= r * chf(\u0026#34;global_scale\u0026#34;); Easy enough!\npoint(), setpointattrib() and Friends Reading Next, we\u0026rsquo;ll need to fetch the user-specified attribute that we want to scale the randomness by. The most familiar way is by using the point() function.\nUser scale attribute\nf@coolscale = pow(relbbox(0, v@P).z, 4.0); In this case we have a user-specified attribute called coolscale. We\u0026rsquo;ll use the point() function and a string parameter chs() to get that value.\nUsing the custom attribute\nSo far so good. We\u0026rsquo;ve queried the custom user attribute and scaled our randomness by it.\nWriting We\u0026rsquo;ve successfully written to pscale so far. But remember that our setup\u0026rsquo;s requirements call for the user to be able to specify the output attribute. Currently, we have it hardcoded to f@pscale.\nIn order to write to a custom attribute, let\u0026rsquo;s add another parameter to specify what the attribute should be called and use the setpointattrib() function to write the value to the points.\nOutput Attrib parameter\nfloat r = rand(i@ptnum); float user_scale = point(0, chs(\u0026#34;user_scale_attrib\u0026#34;), i@ptnum); float scale = r * user_scale * chf(\u0026#34;global_scale\u0026#34;); setpointattrib(0, chs(\u0026#34;output_attrib\u0026#34;), i@ptnum, scale); While this function certainly does what we are asking, it is painfully slow when iterating over many many points, which isn\u0026rsquo;t an uncommon task! So how can we do it all a bit better? Let\u0026rsquo;s take a look at the Bindings tab.\nAttribute Bindings Tab Attribute Bindings tab\nThe idea is pretty straightforward. The Attribute Name is the name of the attribute you really want to write to. Vex Parameter is simply what you\u0026rsquo;ll call that attribute inside your code. Think of this as an alias for the attribute name that you actually care about.\nWe can modify our setup to use this method instead:\nRewrite code\nfloat r = rand(i@ptnum); f@scaled = r * f@user_scale * chf(\u0026#34;global_scale\u0026#34;); Our code has just gotten much simpler. We only need to refer the attributes that we put in the Vex Parameter parameters using the familiar @ syntax.\nNew bindings\nWe can take advantage of the chs() channels we already made, and just channel reference them in the bindings section. That way the interface can stay user-friendly (especially for whenever you want to promote these up to the interface of a digital asset or something).\nSpeed Comparison Let\u0026rsquo;s do a comparison with the Performance Monitor.\nPerformance Test\nWith ~112k points we can see that the setpointattrib() method takes about 0.081 seconds to cook, whereas the Attribute Bindings method takes 0.002 seconds! That\u0026rsquo;s a pretty big difference, though 0.08 seconds is pretty negligible too.\nWhat happens if we try with a a point cloud consisting of 30,000,000 points?\nPerformance Test - 30mio points\nAttribute Bindings wins by a factor of ~30x on my machine. Now the difference between 0.13s and 3.9s per cook might not seem like a huge amount if you\u0026rsquo;re already waiting a minute or so per-frame to process a heavy point cloud (like a big FLIP sim). But consider that in this example we are writing just a single attribute, in one wrangle. In a real-world setup, you might have several attributes and be doing a few different things in different wrangles and steps which can really add up!\nVolumes This technique is especially useful when dealing with fields in Volume VOPs. Have you ever dived inside a Gas Turbulence DOP or any similar nodes? If you look in the Attribute Bindings section, you\u0026rsquo;ll see that SideFX uses these all the time! It\u0026rsquo;s how you\u0026rsquo;re able to specify the name of any Control Field, but internally they only need to use one name!\nLet\u0026rsquo;s try it out on our own. We\u0026rsquo;ll create a Volume VOP that adds noise to both density and temperature. There\u0026rsquo;s actually a shortcut toggle we can use without needing to set all the names ourselves.\nBind Each to Density\nVolume Bindings\nCreate a Volume VOP. Add some nodes inside. Don\u0026rsquo;t add any extra Bind Export nodes, just pipe them out to density. On the Volume Bindings tab uncheck Autobind by Name. Enable Bind Each to Density. Now we\u0026rsquo;ve applied the same operation to all of the fields! This is really useful if you\u0026rsquo;re creating any tools that modify volumes, and you want the user to be able to easily run over fields called anything.\nAttributes to Create Attributes to Create - Default\nThis parameter is often overlooked, and its default is just * - which means any attributes referred to in the wrangle using the @ syntax will be created if it they don\u0026rsquo;t exist already.\nThe default is usually fine. But sometimes, you might be using an attribute temporarily just to do some sort of calculation, and you don\u0026rsquo;t actually want it to be created and passed along through the output. In that case, you can just use the ^ character plus the attribute name to skip it! This is also useful if you have a tool that allows a user attribute to passed in but does not require it.\nTake this for example:\nWe have a setup that modifies the thickness of some curves. By default, the code will apply some randomness. The user is also given the option to provide an attribute by which to multiply the randomized thickness. For clarity, let\u0026rsquo;s provide them a sensible default like thicknessscale (sort of how vellum and other tools across houdini fill it in too).\nParameter defaults and code\nIf we structure our code like so:\nfloat r = rand(@seed + 65536); f@pscale = r * f@scale * chf(\u0026#34;global_scale\u0026#34;); with the following attribute bindings:\nAttribute Bindings\nwe would expect that the f@pscale attribute is scaled by some random number, and the curves will change shape.\nBut what happens if the user doesn\u0026rsquo;t want to do any extra scaling, and they didn\u0026rsquo;t specify any attribute? If no attribute is provided, and the binding is left blank or the attribute doesn\u0026rsquo;t exist we wind up with a bit of an issue\u0026hellip;\nScales are zero\nAll the scales are now zero! Well that\u0026rsquo;s not really what we want\u0026hellip; if the user doesn\u0026rsquo;t specify an attribute (or if it doesn\u0026rsquo;t exist), we should carry on and happily apply just the randomized value to the thickness. Let\u0026rsquo;s modify the code a bit:\nfloat @scale = 1.0; // Initialize it in case the user doesn\u0026#39;t float r = rand(@seed + 65536); f@pscale = r * @scale * chf(\u0026#34;global_scale\u0026#34;); Scales are working now\nThis works excellently! Now, even though the attribute is missing, everything is just multiplied by 1.0, so we\u0026rsquo;re in the clear. But let\u0026rsquo;s look at the attributes now\u0026hellip;\nExtra Attribute\nOh no! Since that default value we have sitting in there wasn\u0026rsquo;t cleared out, and since it doesn\u0026rsquo;t already exist on the points, we wound up creating some attribute called thicknessscale with a value of 1.0! That\u0026rsquo;s sort of annoying. If the user didn\u0026rsquo;t ask for an attribute to be created, we should really just leave it alone.\nLeaving it alone is simple. Just exclude it from that Attributes to Create parameter.\nExclude f@scale attribute\n* ^scale ^seed The attributes specified in this list are the same as the Vex Parameters you\u0026rsquo;re using in your code, even if they are bound to something different.\nNo extra attributes left\nIf the attribute does exist on the points beforehand, don\u0026rsquo;t worry - this option won\u0026rsquo;t cause it to be deleted. It will still pass through just as expected, with the added bonus that since it\u0026rsquo;s being ignored in the Attributes to Create parameter, we aren\u0026rsquo;t able to actually write to it, which means we can\u0026rsquo;t muck it up with our code!\nResult Let\u0026rsquo;s see it in action with the user specifying their own scaling attribute on top of our randomization:\nFinal Result\nFinal Notes Groups We can do most of the same stuff with groups. Just remember than Vex expects the prefix i@group_ before group names, which also applies to the Vex Parameter parameter in the bindings section.\nGroup Bindings\nGroup Bindings Example\nAn important note - if you\u0026rsquo;re using the Output Selection Group parameter to visualize the group in the viewport (and pass the selection to downstream nodes), note that this parameter is expecting Group Name not the Vex Parameter!\nOutput Selection Group\n","permalink":"https://www.jamesrobinsonvfx.com/blog/attribute-bindings/","summary":"Write to attributes with one name while using another in your code","title":"Attribute Bindings"},{"content":" Hipfile: jamesr_vexsource.hiplc\nHoudini offers several ways to duplicate and reuse nodes.\nCopy and paste nodes (Ctrl + c, Ctrl + v). Create an HDA. RMB \u0026gt; Actions \u0026gt; Create Reference Copy \u0026hellip;to name a few.\nSometimes, you might find yourself re-using the same VOP network or VEX wrangle without changing the internal nodes or code. But what happens if you want to change them all at once?\nScenario Let\u0026rsquo;s say we have a VOP network that applies some noisy displacement animation to a character (see hipfile above). There are several other characters in the scene who need the same displacement effect applied to them. We have a few options:\nOption 1: Copy and Paste the VOP Network Copy and Paste\nSimple as that. We can just duplicate it around and we\u0026rsquo;re all set. 90% of the time this will probably be what you do day-to-day. The downside though is that anytime you update the internal nodes/code, you\u0026rsquo;ll have to do the same thing to all the copies\u0026hellip;\nOption 2: Create an HDA HDAs are perfect for when you want to bundle up some nodes and reuse them all over the place. There are numerous advantages to using HDAs that I won\u0026rsquo;t go into in this post, but sometimes creating and tracking an HDA is just a bit overkill. In our case, we have one VOP that makes some noise\u0026hellip;we don\u0026rsquo;t really need to go through the effort of creating an asset for it!\nOption 3: Create a Reference Copy RMB \u0026gt; Actions \u0026gt; Create Reference Copy\nWe could create a Reference Copy which is really just like copying and pasting the node like in the first option, except the new pasted node has relative channel references back to all the parameters on the source node. This works just fine, and we get a copy of all the internal nodes as well. But even with the reference copy, if we were to change the internal nodes of the source VOP network like adding new nodes or removing old ones, those changes would not be reflected in the copies.\nOption 4: Change the Vex Source The last option we\u0026rsquo;ll go over is really the whole point of this post. On each VOP network, there is a parameter called Vex Source. By default, this is is set to Myself, which means it uses the operators inside itself to do all the work.\nVex Source Parameter\nIf we change it instead to Shop, the Shop Path parameter is then exposed, and we can actually set that parameter to another VOP network in the scene.\nWe leave this VOP network empty - its internals are being overridden by the contents of the VOP network specified in that Shop Path parameter!\nSteps VOP Network Shop Path Setup GIF\nTo recap, the steps are as follows:\nCreate a VOP network that does something you want to reuse on other geo. Create an empty VOP network and hook it up to wherever you want to reuse the original. Select the original VOP network and hit Ctrl + c. This will copy the path to the node to the clipboard. Select the empty VOP network, and set the Vex Source parameter to Shop. Paste the copied path to the source VOP network in the Shop Path parameter (if you want this to be a relative path, that\u0026rsquo;s fine too). Changes to the source network are propagated immediately!\nWhat about Wrangles? Hidden inside each wrangle is actually just a VOP network with a Snippet VOP inside!\nVEX wrangles don\u0026rsquo;t have the Vex Source parameter exposed at the top level, so we actually won\u0026rsquo;t be able to use an empty wrangle on each of our other streams.\nInstead, let\u0026rsquo;s just write one wrangle with the code on it that we want to reuse, and the rest of the geometry we want to copy it around to will have empty VOP Networks instead, just like before.\nWrangle Source\nSteps: Create the source wrangle with the desired code. Create an empty VOP network and hook it up to the other geometry we want to process. Dive inside the source wrangle node, and Ctrl + c on the VOP network inside. This copies the path to the node to the clipboard. On each of the new empty VOP networks, set the Vex Source parameter to Shop. Paste the path of the copied VOP network into the Shop Path parameter. Final Notes The biggest downside to this method is that you can\u0026rsquo;t really adjust the parameters on the copies. However, you could get around this by instead using attributes on the geometry to control certain parts of your setup!\nAttributes for Parameters\nChannel Referencing Wrangles Another pretty useful way of referencing another wrangle is to simply channel reference the Snippet parameter from another wrangle.\nChannel Reference Snippet String\nThis way is also useful because you can add parameters to the wrangle copy\u0026rsquo;s interface and update those, and they will get picked up and used while your code lives on just a single wrangle.\n(Thanks Daniel)\nEvaluation Node Path However, if you still want the source wrangle\u0026rsquo;s parameter sliders to affect the copies, you\u0026rsquo;ll need to update the Evaluation Node Path parameter under the Bindings tab of the wrangle copies.\nEvaluation Node Path\nThis tells the wrangle to look at that node instead when trying to figure out where ch() parameters are.\nEvaluation Node Path in Action\n","permalink":"https://www.jamesrobinsonvfx.com/blog/vex-source/","summary":"Use one VOP network or VEX wrangle to drive many others without channel referencing","title":"Vex Source"},{"content":"Overview A few weeks ago, my friend and co-worker Omar Taher came to me with an issue: he had a hair groom made of triangulated cards, and wanted to extract centerline curves from them to use as guides.\nGet it Download the latest release here.\nFull repo here.\nInside the houdini18.5/hda folder you can grab the HDA and put it someplace where Houdini will find it. Otherwise, you can install it as a Houdini Package:\nDownload the release zip Navigate to your Houdini user preferences folder (ie. ~/houdini18.5) Create a folder called packages if it doesn\u0026rsquo;t exist yet Copy the downloaded zip into packages Extract the contents, and delete the zip archive if you want Drag the file cards_to_curves.json up one level into to that packages folder There is also a demo file located at houdini18.5/hip with some usage examples.\nSee the the help card on the node for more detailed info.\nProcess Sounds easy enough at first, but given some wonky polygon winding and shapes, it took a little extra work to make sure it was stable on every card.\nFirst Attempt At first, not knowing much about how groom artists create hair cards, I took a VEX approach that matched up pairs of points based on their neighbors, and added a point at their center.\nUnfortunately, that only worked when the cards were made with one row of alternating triangles, and after downloading a few more free hair card grooms, I realized that this method fails spectacularly if the artist created it differently.\nFinal Luckily, one thing all good hair card grooms have in common: they have nice UVs! Should have thought of that sooner! This makes finding the centerline a breeze:\nEvaluate the connectivity. Split geo by UV seams, and promote uv attribute to points (if it isn\u0026rsquo;t there already). Swap P for UV, so the points now look like a UV layout, but in world space near the origin in the viewport. Iterate over each connected piece (card), and create a line down the center of the bounding box, from the top to the bottom. Add some more points to these lines with a Resample. Ray the lines to the flattened hair card geo. Use an Attribute Interpolate to put them back into world space. Checkout the hipfile to see the setup, and crack open the hda for a deeper look.\nTool Features As mentioned above, this node will create guide curves from hair cards.\nSome different grooms\nBy default, the tool is pretty straight forward. Plug in the static cards into the first input, get curves out! As long as you have a uv attribute (that works) you should get something useable.\nSingle Card \u0026amp; Guide Geometry Single Card\nEnable the Single Card parameter to scrub through the cards one at a time for a quick debugging visualization.\nStick to Animation If a second input is connected, the guides will interpolate attributes (including position) from that geometry stream.\nMake sure the topology matches the original cards from the first input!\nStick to Animation\nExploded View\nCaveats If you\u0026rsquo;re getting bad guides that zig zag, or look like they\u0026rsquo;re spanning across multiple guides, make sure the input cards are clean. There is a Poly Doctor embedded in the node that should help clean up non-manifold geometry, but sometimes it can\u0026rsquo;t do all the work! Make sure that any problem cards are actually being treated as separate connected islands per-card. Otherwise either fix them, or delete them!\nConclusion Enjoy! If you have any problems, please feel welcome to add an issue to the github repo, or reach out to me directly.\nHairstyles\n","permalink":"https://www.jamesrobinsonvfx.com/projects/hair-cards-to-guide-curves/","summary":"Convert hair card geometry (like from a game engine) to guide curves","title":"Hair Cards to Guide Curves"},{"content":" Hipfile: jamesr_decay.hip\nOne of the most common use cases for the Solver SOP is to accumulate values over time.\nAccumulating \u0026amp; Substeps Accumulating a value like color or density over time is pretty straightforward.\nAdd to the value from the previous timestep Clamp as needed f@density += chf(\u0026#34;accumulate\u0026#34;); f@density = clamp(f@density, 0, 1.0); When you introduce substeps, the accumulation can get a little crazy! Since the solver is doing this addition each timestep, you\u0026rsquo;ll wind up increasing the value much more quickly than with just one substep. Luckily the solution is pretty straight forward: multiply your accumulation scale by f@TimeInc before adding.\nf@density += chf(\u0026#34;accumulate\u0026#34;) * f@TimeInc; f@density = clamp(f@density, 0, 1.0); Decaying \u0026amp; Substeps Accumulating was easy enough right? At first you might think the same could be done for decaying or fading a value over time (like I did\u0026hellip;oof!).\nIf you\u0026rsquo;re decreasing the value by subtracting, multiplying by f@TimeInc is just fine.\nBut if you\u0026rsquo;re doing a fading effect where you\u0026rsquo;re multiplying by some value between 0 and 1, multiplying by the time increment will actually have the opposite effect!\nImagine you start with a f@density value of 1.0, and you have a decay rate of 0.98. At 1 substep, each frame you are multiplying the previous value by 0.98. So by frame 2, your f@density attribute is 0.98, frame 3 0.9604\u0026hellip;and so on.\nBut if you multiply your decay rate by the time increment, you get a number that\u0026rsquo;s much much lower!\n// f@Timeinc = 0.0416 0.98 * f@Timeinc = 0.040768 In this case, each substep we\u0026rsquo;d be multiplying the value by 0.040768. Even after just a single step we\u0026rsquo;d probably have all our value eaten away, which is exactly the problem we want to avoid.\nGet to the solution already! Alright alright, we actually have a few ways to solve this one.\nSubtract and Clamp This first way is similar to the additive accumulation method above (subtraction is really just addition in disguise anyways). Instead of decreasing the value by multiplying, we\u0026rsquo;ll just subtract some small amount each timestep:\nv@Cd.x = max(0, v@Cd.x - (chf(\u0026#34;decay\u0026#34;) * f@Timeinc)); Power Function The second way uses VEX\u0026rsquo;s pow() function to decay the value over time.\nThis method will have a different decaying behavior vs just doing a simple multiplication on a single substep. But it tends to look pretty natural so go ahead and try it out\nv@Cd.x *= pow(chf(\u0026#34;decay\u0026#34;), f@Timeinc); Easy as that! Try it in a Solver SOP with different substep values and see the comparison (or take a look at the attached hipfile). Should be pretty close.\nLinear Combination DOP This method is less for when you\u0026rsquo;re trying to do this in a SOP solver, and more for if you\u0026rsquo;re building a setup in DOPs (and want to use this microsolver for something!)\nIt\u0026rsquo;s really as simple and changing the dropdown next to the Coefficient parameter from None to e^Timestep. Looks pretty similar to what we just did above!\nGas Linear Combination DOP\n","permalink":"https://www.jamesrobinsonvfx.com/blog/decay-values/","summary":"Decay values in a Solver SOP while respecting substeps","title":"Decay Values"},{"content":" Hipfile: jamesr_ftrim.hip\nProblem Sometimes you want to reference the value of a parameter and display it as a string to put in a Font SOP, or the Viewport Comment of a Camera node when you\u0026rsquo;re wedging sims or making some sort of visualizer.\nBut quite often, if you\u0026rsquo;re referencing a float parameter, you wind up getting allllll the digits that come with it, full precision and all, rather than just the nice value you see in the interface.\nSuper long string of numbers when channel referencing\nie.\n0.04 becomes\n0.040000000000000001 which is probably not what you want!\nA possible solution to trim off some of the extra digits might look something like\nfloor(ch(\u0026#34;/some/parm\u0026#34;) * 1000)/1000 Unfortunately, this fails too :(\nSolution The solution is actually quite simple! We can use the ftrim() function from HScript. ftrim() will strip off all those unwanted digits and leave you with a nice clean value, pretty much as you typed it!\nSome Parameter Value: `ftrim(ch(\u0026#34;/some/parameter\u0026#34;))` Using ftrim() to shore it up\nOf course, this also works in a Font SOP too.\nDemo on a Font SOP\nUpdate 9 Jan 2022 Here\u0026rsquo;s a handy snippet for programmatically wrapping channel references in ftrim(). Taken from the Linewriter tool.\n","permalink":"https://www.jamesrobinsonvfx.com/blog/ftrim-function/","summary":"Trim unwanted digits from parameter values","title":"ftrim() HScript function"},{"content":" View it on GitHub This node uses a Dictionary Attribute to store parameter data from the Attribute from Parameters SOP and retrieve it for inspection. This is useful for storing data about how a cache was generated when wedging values.\nSee help card and demo file for more info.\n","permalink":"https://www.jamesrobinsonvfx.com/projects/inspect-node-data/","summary":"SOP-level HDA for storing, retrieving, and inspecting parameters from nodes","title":"Inspect Node Data"},{"content":" Hipfile: jamesr_vdbreshapesdfclose.hip\nDilate and Erode (Old) Most people are probably familiar with the following workflow for sealing up gaps and holes in an SDF using 2 VDB Reshape SDF nodes:\nSet the first one to Dilate Set the second one to Erode Channel reference the Offset parameter from the dilating node to the Offset parameter of the eroding node. Adjust the offset until you\u0026rsquo;re happy If you want to keep a filled interior, don\u0026rsquo;t forget to set the Trim parameter to None (Houdini 18.5+)!\nOld way\nClose (New) Not sure when this was added (or maybe it has been here the whole time!), but there is another method that does the exact same thing in one go: Close.\nNew way\nConclusion A side-by-side comparison of the two looks like you get the same result!\nSide by side comparison\n","permalink":"https://www.jamesrobinsonvfx.com/blog/vdb-reshape-sdf-close/","summary":"Faster way to dilate and erode an SDF","title":"VDB Reshape SDF Close"},{"content":" Hipfile: jamesr_alembicrbdlayers.hip\nOr follow along on hdbp.io\nOverview There are plenty of ways to transfer RBD data from one application to another. Some facilities might have proprietary tools to make this pretty straightforward and quick. Others might use USD. But what if you don\u0026rsquo;t have either option?\nOne kind of interesting way of doing it is to use Alembic Layering.\nConcept Obstacles One thing we absolutely want to avoid when writing RBD geo to Alembic is writing all the pieces out as a single, unpacked deforming point cache. This is a huge waste of time and space because:\nAll of the points and mesh data will be written on each frame. We are forced to use deformation blur. If we need more detailed motion blur, we must write more motion samples into the cache. Multiply those factors by all of your iteration time and you get a really slow turnaround!\nPacked Geometry to the Rescue Houdini is perfectly capable of writing its own packed geometry format as packed Alembic primitives. Houdini treats each packed prim like its own object and so each primitive gets its own transform. This is great because:\nWe only need to wait for the mesh data to write into the Alembic cache once. Alembic caches are much smaller, since only one copy of the mesh data exists. The rest of the data is just time-varying attributes and transform matrices. We don\u0026rsquo;t need to use motion samples or deformation blur. Take it a Step Further This is all sounding pretty great! And for a small, lower-res sim this would probably suffice. But what if we have a bigger sim, with pretty high-res pieces? When writing the Alembic to disk, we would still need to wait for Houdini to transform the packed high res pieces, and write their transforms.\nInstead, what if we wrote the high-res static pieces to disk once, and anytime we wanted to change the sim and export it, we write only the transforms from the low-res sim to a cache, and leave the high-res static piece alone?\nAlembic let\u0026rsquo;s us do exactly that, using Alembic Layering!\nLayering The concept behind layering transforms is simple:\nWrite one static Alembic cache of the high-res pieces. Write one animated Alembic cache of only the transforms of each piece. Load the static cache, and layer the transforms on top so that they override the static static transforms. Requirements s@path Attribute Each piece needs to have a s@path attribute that corresponds to its place in a a hierarchy. It\u0026rsquo;s important that each piece has room for both a Transform and Shape. Here\u0026rsquo;s an example of a good looking s@path:\nSet Path from Name\ns@path = sprintf(\u0026#34;pieces_grp/%s_geo/%s_geoShape\u0026#34;, s@name, s@name); It\u0026rsquo;s also crucial that the paths on the high-res geometry and the low-res transform match up!\nPacked Geometry / Fragments It\u0026rsquo;s important that each piece is packed. This is how Houdini will get the transform it needs. Make sure that the pieces are backed before transforming them. If you\u0026rsquo;re using this method with a Copy to Points SOP, or a Transform Pieces SOP, make sure the geo is packed before moving them around. This way, the primintrinsic:packedfulltransform will actually get updated! (ie. don\u0026rsquo;t copy/xform the unpacked pieces, then use an Assemble SOP to pack \u0026rsquo;em up after.)\nThere is a little trick to get the pivots to line up correctly, so please see the demo file for details on that if you\u0026rsquo;re exporting RBD pieces and noticing some misalignment!\nROP it Out Output\nIn order for the Alembic to work for our purposes, a few of the defaults need to be changed on the Alembic ROP.\nBoth ROPs Enable Hierarchy \u0026gt; Build Hierarchy from Attribute. Ensure Path Attribute is the same as the one you made earlier. Geometry \u0026gt; Packed Transform should be set to Merge With Parent Transform Disable Use Instancing Where Possible if this is an RBD sim with unique pieces. High Res Pieces Output Settings\nTransforms Cache Make sure to disable Create Shape Nodes. Low Res Xform Output Settings\nSince we are only concerned with storing the transformation of each piece, don\u0026rsquo;t write the shape data in this cache. Otherwise, it will overwrite the high res mesh completely when we layer it back in!\nImport in your DCC of Choice The most common target application is probably going to be Maya. I\u0026rsquo;m not too familiar with the procedurals for any other render engine aside from Arnold, so I\u0026rsquo;ll stick to what I know.\nIf you\u0026rsquo;re rendering with Arnold in Houdini, it\u0026rsquo;s as simple as setting the render flag of an object to render an Alembic SOP. Arnold will render Packed Alembics as procedurals by default.\nAlembic SOP in Houdini with layers\nRecommendations Do Don\u0026rsquo;t Load Alembic as a GPU Cache (Maya) or as an Arnold Standin Procedural Do Not just do a File \u0026gt; Import and load the cache as Maya geometry. For a heavy sim with thousands of transforms and shape nodes, you’re likely to crash Maya! ","permalink":"https://www.jamesrobinsonvfx.com/blog/xform-pieces-alembic-layering/","summary":"Create two separate Alembic caches for geometry and transforms and combine them later","title":"Transform RBD Pieces with Alembic Layering"},{"content":"Easily switch any value for another in a hipfile.\nGoing through and manually swapping $HIP for $JOB, or switching any value for another noe in an entire hipfile can be a real pain. You could try going the long way (looking at each parm and changing by hand\u0026hellip;ouch!), or by iterating all the parms on all the nodes with Python. Or, you can use a simple built-in HScript command: opchange.\nopchange makes it really simple to swap values across the entire scene, or over a limited scope of nodes.\nExample Let\u0026rsquo;s say you were loading a bunch of HDRIs from some sort of library you have elsewhere on disk, but now you need to share the project with someone else. You\u0026rsquo;ve copied all the light textures from you library location into $JOB/tex, but now you need to change all the paths on the lights in your hipfile. We can use opchange to make it a bit easier.\nopchange D:/Library/HDRI \\$JOB/tex Now all references to D:/Library/HDRI should have been replaced with $JOB/tex.\nGotchas If you\u0026rsquo;re swapping a variable, and you want to search for the unexpanded version, ie the literal string $HIP, make sure to escape the $ with a \\, otherwise Houdini will be searching for the expanded versions, like ~/project/myproject or wherever $HIP is pointing to instead.\nopchange \\$HIP \\$JOB/hip Limit the Scope We don\u0026rsquo;t have to search the entire scene in this case, since we know that all of our lights are going to exist at /obj.\nopchange -p /obj D:/Library/HDRI \\$JOB/tex Duplicated a node and want to change the new node\u0026rsquo;s parm reference? Use the -i flag.\nopchange -i -p /obj/sheepnmoon/mat/fuzz_moon sheep_ moon_ ","permalink":"https://www.jamesrobinsonvfx.com/blog/opchange/","summary":"Quickly Search/Replace All Parameters in Your Hipfile","title":"opchange"},{"content":"I recently discovered that you can actually set the viewport drawing modes to be unique per Shading Mode. ie. when templating geo, you can shade with Hidden Line Ghost instead of the default template wireframe.\nViewport Settings\nThis combined with a thinner wire width makes for a pretty pleasing experience! The ghost mode when templated also sort of helps show a bit more depth.\n","permalink":"https://www.jamesrobinsonvfx.com/blog/viewport-draw-modes/","summary":"Set different draw settings per viewport shading mode","title":"Viewport Draw Modes"},{"content":"Color Palette Ramp For the full README, view it on GitHub ","permalink":"https://www.jamesrobinsonvfx.com/projects/colorpalette-ramp/","summary":"Houdini SOP node to extract a color palette from an image using K-Means Clustering","title":"Color Palette Ramp"},{"content":" Hi!\nI\u0026rsquo;m a Houdini FX TD currently working at WētāFX in Wellington 🇳🇿. Before that, I spent a few years at The Mill working on various commercial projects.\nI enjoy creating high quality FX elements, as well as tool-building and pipeline development.\nYou can find my full resume here.\nGet in touch by emailing james at jamesrobinsonvfx.com\n","permalink":"https://www.jamesrobinsonvfx.com/about/","summary":"Hi!\nI\u0026rsquo;m a Houdini FX TD currently working at WētāFX in Wellington 🇳🇿. Before that, I spent a few years at The Mill working on various commercial projects.\nI enjoy creating high quality FX elements, as well as tool-building and pipeline development.\nYou can find my full resume here.\nGet in touch by emailing james at jamesrobinsonvfx.com","title":"About 👋"}]